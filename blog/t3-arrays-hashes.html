<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../favicon.ico">

    <title>Blog Post</title>

    <!-- Bootstrap core CSS -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="../css/jumbotron.css" rel="stylesheet">

    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    <script src="../js/ie-emulation-modes-warning.js"></script>

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="navbar-wrapper">
      <div class="container">

        <nav class="navbar navbar-inverse navbar-fixed-top">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="#">Phase 0 Blog</a>
            </div>
            <div id="navbar" class="navbar-collapse collapse">
              <ul class="nav navbar-nav">
                <li><a href="https://anthonycastelli01.github.io/">Home</a></li>
                <li class="active"><a href="https://anthonycastelli01.github.io/blog">Blog</a></li>
                <li class="dropdown">
                  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Projects<span class="caret"></span></a>
                  <ul class="dropdown-menu">
                    <li><a href="https://anthonycastelli01.github.io/projects/index.html">Main Project Page</a></li>
                    <li role="separator" class="divider"></li>
                    <li><a href="projects/electronics.html">Electronics</a></li>
                    <li><a href="#">Dev Bootcamp</a></li>
                  </ul>
                </li>
                <li><a href="https://anthonycastelli01.github.io/about.html">About</a></li>
              </ul>
            </div>
          </div>
        </nav>

      </div>
    </div>

    <!-- Main jumbotron for a primary marketing message or call to action -->
    <div class="jumbotron">
      <div class="container">
        <h1>Arrays and Hashes</h1>
        <h2>Basic Ruby Storage Structures</h2>
        <h4>June 29, 2015</h4>
      </div>
    </div>

    <div class="container">
      <div class="col-md-8">
        <p>This week in phase0 we learned about the basics of Ruby and how to do basic variable manipulation. In our second to last challenge, we learned about Ruby arrays and hashes, special types of variables used to store many values at once. Arrays and hashes are similar in that they use a key:value pair to get values in and out of storage. The main difference being that arrays use a numbering system for keys and hashes use any type of object as a key.</p>

        <h3>Arrays</h3>

        <p>The structure of arrays is such that the data is stored as values which are referenced to by number values. These values start at zero, so if you have a number of values 'n', the order would be "0, 1, 2, ..., n-1". This is known as 'zero indexed', which is a common thing in programming languages.</p>

        <figure>
          <img src="../imgs/array.png" alt="Array Visualization"></img>
          <figcaption><b>Figure 1:</b> An array can be visualized as a container full of numbered boxes.</figcaption>
        </figure>

        <p>An array can be visualized as a container with smaller compartments inside, each of which has a (positive including zero) number on the outside. These boxes contain values that need to be stored, so in the analogy this would be like looking at the pile of containers for the one numbered with the number you were looking for, and picking it out to mess with the contents. Usually these boxes are considered to be sorted in numerical order, so it's not quite the same as the analogy, but these values aren't necessarily stored like that in practice.</p>

        <p>When an array is initialized, it defults to having all of its values set to the 'nil' value. This is Ruby's way of saying that nothing is stored at these locations, so in effect the array is empty. Each value is set this way from the beginning unless it is initialized in an atypical way. Once the array is used to store values, these 'nil' placeholders are replaced with data. Data stored inside arrays can be of any object type, including other arrays! The usual way to initialize an empty array is like so:</p>

        <pre class="ruby">myArray = []</pre>

        <p>Square brackets are used in Ruby to access both arrays and hashes, but in order to represent an empty array two empty brackets are used. In order to access a value at a specific index, the name of the array followed by two brackets with the index inside woudl be used, as below:</p>

        <pre class="ruby">myArray[0] = "Hello"</pre>

        <p>In this example, the value of the array myArray at index 0 is changed to the string "Hello". Values can be changed in a more automated fashion using an iterative loop, where a value is inserted into the brackets that is changed during every iteration. This can be seen below:</p>

        <pre class="ruby">
for i in 0..10
  myArray[i] = "This is the value at index #{i}"
end</pre>

        <p>This would set the first 10 index values of the array named myArray to a helpful note about what was stored at the corresponding location for the index.</p>

        <h3>Hashes</h3>

        <p>Hashes are similar in practice to arrays, but are different in what can be used for the keys used to find the internal values. The terminology is also a little different than arrays, where an array was considered to be ordered and had an index value to find the data, hashes use 'keys' to find data, which is also known as a 'value'. Thus, storage in a hash is based on key:value pairs, where a key can be a number of different things. Thus, the biggest difference between a hash and an array is that while data in an array is accessed with numbers, hash values can be accessed with strings or other objects as well!</p>

        <p>An empty hash is also defined differently than an array. Where arrays used square brackets, hashes use {curly brackets} to define an empty value. Thus, to define an array in Ruby, one would type in:<p>

        <pre class="ruby">myHash = {}</pre>

        <p>The hash will still give null values for any undefined values, the only difference being that a test like myHash["one"] will give a null value instead of only numerical values. A hash can still accept numerical values for keys though, so if you felt that array keys being only integers was limiting, hashes are probably for you!</p>

        <p>Iterators can still be used in a hash, with the only change being that you will need to come up with a way of generating the correct values unless a special loop is used. For example, </p>

        <pre class="ruby">
for i in 1..10
  hash["loc" + i.to_s] = "Location #{i}"
end</pre>

        <p>This code will give ten values of strings like "loc1" and "loc2" values like "Location 1" and "Location 2". This is nice, but in order to get back at these values we can no longer use a simple numerical iteration loop, and have to use a more creative generator for strings that correspond to these locations. However, hashes have special functions that make their keys and values easier to access. For example:</p>

        <pre class="ruby">hash.each{|key, value| puts value}</pre>

        <p>This will go through all of the keys and print out the values associated with them. However, the keys may not be sorted in order so don't depend on that!</p>
      </div>

      <hr class="col-md-8">

      <footer class="col-md-8">
        <p>&copy; 2015 Anthony Castelli.</p>
      </footer>
    </div> <!-- /container -->


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../js/vendor/jquery.min.js"><\/script>')</script>
    <script src="../js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../js/ie10-viewport-bug-workaround.js"></script>
  </body>
</html>